fin will have an api directly on it, rather than return complex items

fin.subscrube instead of fin.depend, and subscribe will *not* be called until the value has been loaded. This will make it less complex to implement "Loadin..." vs no value

Reference counting per channel
	The data layer keeps track of # of dependencies
	On front side, it calls net subscribe/unsubscribe accordingly
	On server side, it calls redis subscribes/unsubscribes 

mutations.js 
	you give mutations the data layer
	you pass mutations a mutation - it modifies state in the data layer and publishes on appropriate channels

query.js
	you give query the data layer
	you ask query for an item set - it subscribes to the appropriate channels
	
Where do queries get computed?